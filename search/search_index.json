{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Kform is a framework that brings the power of 'KRM as code or data' to Kubernetes. With Kform, orchestrating KRM resources becomes a easy through intuitive and human-readable configuration files. These files are not only reusable and shareable but can also be version-controlled, ensuring seamless collaboration among team members.</p> <p>At its core, Kform empowers you to manage the entire lifecycle of KRM resources specified through the configuration files consistently. Whether it's deployment, scaling, or any other operation, Kform streamlines the process for any resource modeled as KRM. This framework is designed to enhance efficiency and maintainability, making Kubernetes resource orchestration a straightforward and manageable task.\"</p>"},{"location":"#why","title":"Why?","text":"<ul> <li>manage any KRM resource</li> <li>track changes     stored through the k8s api</li> <li>declarative     describe end state</li> <li>standardize     modules</li> <li>collaborate</li> </ul>"},{"location":"#join-us","title":"Join us","text":"<p>Have questions, ideas, bug reports or just want to chat? Come join to the Kubenet discord server.</p>"},{"location":"01-getting-started/choreo/01_getting_started/","title":"Getting Started","text":"<p>First check the prerequisites. </p>"},{"location":"01-getting-started/choreo/01_getting_started/#setup-environment","title":"Setup environment","text":"<p>This exercise will walk through a basic Hello world example. The API is already generated</p> <p>This exercise will walk through a basic Hello world example. The API is already generated</p> <p>clone the choreo-examples git repo</p> <pre><code>git clone https://github.com/kform-dev/choreo-examples\n</code></pre> <p>Best to use 2 windows, one for the choreo server and one for the choreo client, since the choreo server will serve the system</p>"},{"location":"01-getting-started/choreo/01_getting_started/#choreo-server","title":"choreo server","text":"<p>start the choreoserver</p> <pre><code>choreoctl server start choreo-examples/hello-world/\n</code></pre> <p>The choreoserver support a version controlled backend but we dont explore this in this exercise.</p> <pre><code>{\"time\":\"2024-09-30T19:26:06.771564+02:00\",\"level\":\"INFO\",\"message\":\"server started\",\"logger\":\"choreoctl-logger\",\"data\":{\"name\":\"choreoServer\",\"address\":\"127.0.0.1:51000\"}}\nbranchstore update main oldstate &lt;nil&gt; -&gt; newstate CheckedOut\n</code></pre>"},{"location":"01-getting-started/choreo/01_getting_started/#choreo-client","title":"choreo client","text":"<p>With the following command we can explore the api(s) supported by the system. We see the helloworlds api being present, which got loaded when we started the server</p> <pre><code>choreoctl api-resources\n</code></pre> <pre><code>&amp;{upstreamrefs choreo.kform.dev v1alpha1 UpstreamRef  false [pkg knet]}\n&amp;{libraries choreo.kform.dev v1alpha1 Library  false [choreo]}\n&amp;{apiresources choreo.kform.dev v1alpha1 APIResources  true []}\n&amp;{configgenerators choreo.kform.dev v1alpha1 ConfigGenerator  false [pkg knet]}\n&amp;{customresourcedefinitions apiextensions.k8s.io v1 CustomResourceDefinition  false []}\n&amp;{reconcilers choreo.kform.dev v1alpha1 Reconciler  false [choreo]}\n&amp;{helloworlds example.com v1alpha1 HelloWorld HelloWorldList true []}\n</code></pre> <p>When executing the following command no result should be shown, since no hello world resources are loaded</p> <pre><code>choreoctl get customresourcedefinitions.apiextensions.k8s.io\n</code></pre> <p>Autocompletion should work, maybe try TAB completion iso copying the full command</p> <p>Now run the reconciler</p> <pre><code>choreoctl run once\n</code></pre> <p>you should see the reconciler <code>example.com.helloworlds.helloworld</code> being executed.</p> <pre><code>execution success, time(sec) 0.0031725\nReconciler                         Start Stop Requeue Error\nexample.com.helloworlds.helloworld     2    2       0     0\n</code></pre> <p>What just happened?</p> <p>a. the reconciler got loaded</p> HelloWorld Reconciler <pre><code>finalizer = \"example.com/ready\"\nconditionType = \"Ready\"\ndef reconcile(helloworld):\nspec = helloworld.get(\"spec\", {})\nspec[\"greeting\"] = \"hello choreo\"\nhelloworld['spec'] = spec\nreturn reconcile_result(helloworld, False, 0, conditionType, \"\", False)\n</code></pre> <p>b. The reconciler registered to be informed on any HelloWorld resource change</p> <pre><code>    group: example.com\nversion: v1alpha1\nkind: HelloWorld\n</code></pre> HelloWorld Reconciler Hook <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: example.com\nversion: v1alpha1\nkind: HelloWorld\nselector: {}\n</code></pre> <p>c. The reconciler business logic got triggered by adding this HelloWorld manifest</p> Hello World manifest <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nname: test\nnamespace: default\n</code></pre> <p>let's see if it performed its job, by looking at the details of the HelloWorld manifest</p> <pre><code>choreoctl get helloworlds.example.com test -o yaml\n</code></pre> <p>We should see spec.greeting being changed to <code>hello choreo</code></p> <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nannotations:\napi.choreo.kform.dev/origin: '{\"kind\":\"File\"}'\ncreationTimestamp: \"2024-09-30T17:49:34Z\"\ngeneration: 1\nname: test\nnamespace: default\nresourceVersion: \"1\"\nuid: deedbf64-b348-477e-9fbb-d2738ab4f3b0\nspec:\ngreeting: hello choreo\nstatus:\nconditions:\n- lastTransitionTime: \"2024-09-30T17:49:34Z\"\nmessage: \"\"\nreason: Ready\nstatus: \"True\"\ntype: Ready\n</code></pre> <p>\ud83c\udf89 You ran you first choreo reconciler. \ud83e\udd18</p> <p>Did you notice none of this required a kubernetes cluster? Choreo applies the kubernetes principles w/o imposing all the kubernetes container orchestration primitives.</p> <p>Try changing the business logic from <code>Hello Choreo</code> to <code>hello &lt;your name&gt;</code> and execute the business logic again</p> <pre><code>def reconcile(helloworld):\nspec = helloworld.get(\"spec\", {})\nspec[\"greeting\"] = \"hello wim\"\nhelloworld['spec'] = spec\nreturn reconcile_result(helloworld, False, 0, conditionType, \"\", False)\n</code></pre> <p>This should result in the following outcome if we run the business logic again.</p> <pre><code>choreoctl run once\n</code></pre> <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nannotations:\napi.choreo.kform.dev/origin: '{\"kind\":\"File\"}'\ncreationTimestamp: \"2024-09-30T17:49:34Z\"\ngeneration: 1\nname: test\nnamespace: default\nresourceVersion: \"1\"\nuid: deedbf64-b348-477e-9fbb-d2738ab4f3b0\nspec:\ngreeting: hello wim\nstatus:\nconditions:\n- lastTransitionTime: \"2024-09-30T17:49:34Z\"\nmessage: \"\"\nreason: Ready\nstatus: \"True\"\ntype: Ready\n</code></pre> <p>You can also introduce an error and see what happens; e.g. change <code>greeting</code> to <code>greetings</code> which is an invalid json key in the schema.</p> <pre><code>def reconcile(helloworld):\nspec = helloworld.get(\"spec\", {})\nspec[\"greetings\"] = \"hello wim\"\nhelloworld['spec'] = spec\nreturn reconcile_result(helloworld, False, 0, conditionType, \"\", False)\n</code></pre> <p>when executing</p> <pre><code>choreoctl run once\n</code></pre> <p>the following result is obtained, indicating the schema error</p> <pre><code>execution failed example.com.helloworlds.helloworld.HelloWorld.example.com.test rpc error: code = InvalidArgument desc = fieldmanager apply failed err: failed to create typed patch object (default/test; example.com/v1alpha1, Kind=HelloWorld): .spec.greetings: field not declared in schema\n</code></pre>"},{"location":"01-getting-started/choreo/02_prereq/","title":"Prerequisites","text":""},{"location":"01-getting-started/choreo/02_prereq/#cpu-architecture","title":"CPU architecture","text":"<p>All the choreo components run on both AMD and ARM based CPU</p>"},{"location":"01-getting-started/choreo/02_prereq/#operating-system","title":"Operating system","text":"<p>We tested on WSL for windows and Linux and darwin OS.</p>"},{"location":"01-getting-started/choreo/02_prereq/#choreoctl","title":"choreoctl","text":"<p>Choreoctl is a command line tool for communicating with a Choreo server.</p> <p>choreoctl is a single binary built for linux and Mac OS, distributed via ghreleases. It</p> linux/Mac OSPackages <p>To download &amp; install the latest release the following automated installation script can be used.</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\"\n</code></pre> <p>As a result, the latest <code>choreoctl</code> version will be installed in the /usr/local/bin directory and the version information will be printed out.</p> <p>To install a specific version of <code>choreoctl</code>, provide the version with -v flag to the installation script:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\" -- -v 0.0.1\n</code></pre> <p>Linux users running distributions with support for deb/rpm packages can install choreoctl using pre-built packages:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\" -- --use-pkg\n</code></pre>"},{"location":"01-getting-started/choreo/02_prereq/#choreoctl-autocomplete","title":"choreoctl autocomplete","text":"bashzsh <pre><code>source &lt;(choreoctl completion bash) # set up autocomplete in bash into the current shell, bash-completion package should be installed first.\necho \"source &lt;(choreoctl completion bash)\" &gt;&gt; ~/.bashrc # add autocomplete permanently to your bash shell.\n</code></pre> <pre><code>source &lt;(choreoctl completion zsh)  # set up autocomplete in zsh into the current shell\necho '[[ $commands[choreoctl] ]] &amp;&amp; source &lt;(choreoctl completion zsh)' &gt;&gt; ~/.zshrc # add autocomplete permanently to your zsh shell\n</code></pre>"},{"location":"01-getting-started/kform/01_getting_started/","title":"Getting Started","text":"<p>First check the prerequisites. </p>"},{"location":"01-getting-started/kform/01_getting_started/#setup-environment","title":"Setup environment","text":"<p>see kform-examples</p>"},{"location":"01-getting-started/kform/02_prereq/","title":"Prerequisites","text":""},{"location":"01-getting-started/kform/02_prereq/#cpu-architecture","title":"CPU architecture","text":"<p>kform runs on both AMD and ARM based CPU</p>"},{"location":"01-getting-started/kform/02_prereq/#operating-system","title":"Operating system","text":"<p>We tested on WSL for windows and Linux and darwin OS.</p>"},{"location":"01-getting-started/kform/02_prereq/#kform","title":"kform","text":"<p>kform is a command line tool for executing kform plans/packages.</p> <p>kform is a single binary built for linux and Mac OS, distributed via ghreleases. It</p> linux/Mac OSPackages <p>To download &amp; install the latest release the following automated installation script can be used.</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/kform/raw/main/install.sh)\"\n</code></pre> <p>As a result, the latest <code>kform</code> version will be installed in the /usr/local/bin directory and the version information will be printed out.</p> <p>To install a specific version of <code>kform</code>, provide the version with -v flag to the installation script:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/kform/raw/main/install.sh)\" -- -v 0.0.1\n</code></pre> <p>Linux users running distributions with support for deb/rpm packages can install kform using pre-built packages:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/kform/raw/main/install.sh)\" -- --use-pkg\n</code></pre>"},{"location":"02-language/01_about/","title":"KForm configuration language introduction","text":"<p>The <code>KForm</code> configuration language serves as a fundamental extension of the Kubernetes resource model (KRM). By utilizing <code>KForm</code>, users can craft configuration files that instruct the system on which plugins to install, what data to retrieve, and which resources to manage. Through the expressive capabilities of the <code>KForm</code> language, users can establish dependencies between resources and execute manipulations on Kubernetes resources using expressions.</p>"},{"location":"02-language/01_about/#the-kform-configuration-language","title":"The KForm configuration language","text":"<p>The primary function of the <code>KForm</code> configuration language is to define Kubernetes resource manifests that render the resources defined by the <code>Kform package/module</code>. Its additional language features are designed to enhance the flexibility and convenience of resource definition.</p> <p>A <code>Kform</code> configuration is a set of KRM manifests that tells <code>Kform</code> how to manage a given collection of Kform KRM resources. A <code>Kform</code> configuration can consist of multiple files in a given directory. We also call the collection of KRM manifests a <code>Kform package</code> or a <code>Kform module</code>.</p> <p>The syntax of the <code>KForm</code> language consists of a few basic elements:</p> <pre><code>apiVersion: &lt;...&gt;\nkind: &lt;...&gt;\nmetadata:\nname: &lt;...&gt;\nannotations:\nkform.dev/block-type: &lt;kform blockType&gt;\nkform.dev/resource-type: &lt;kform resourceType&gt; kform.dev/resource-id: &lt;kform resourceID&gt; kform.dev/&lt;kform attributes&gt;: &lt;kform attribute value or expression&gt; spec:\nvalue: &lt;expresion&gt;\n</code></pre> <ul> <li>A KForm KRM resource, also known as a 'block' in Kform, serves as the fundamental unit of a resource definition. These resources possess a <code>block type</code> comprising mandatory and/or optional attributes. Depending on the <code>block type</code>, a Kform <code>resource type</code> may be required.</li> <li>A <code>KForm</code> <code>resource ID</code> defines the identifier of a <code>Kform</code> block and is identified either by the explicit <code>kform.dev/resource-id</code> annotation or will be derived from the <code>metadata.name</code> if the <code>kform.dev/resource-id</code> annotation is not defined.</li> <li>Expressions in <code>KForm</code> represent values, either literally or by referencing and combining other values. They can appear as values for attributes or within other expressions.</li> </ul> <p>The <code>KForm</code> configuration language operates in a declarative manner, describing the intended goal rather than the steps to achieve it. The ordering of KRM resources and the files where they are defined is irrelevant. Kform only considers files in the root Kform directory, allowing users to define KRM resources across multiple or individual files as desired. KForm establishes the order of operations based on implicit and explicit relationships between resources.</p>"},{"location":"02-language/01_about/#example","title":"Example","text":"<p>The following example <code>KForm module/package</code> describes a simple application deployment, to give a sense of the overall structure and syntax of the <code>KForm</code> configuration language. Similar configurations can be created for any KRM resource.</p> <pre><code>---\n# blockType: input, resourceID: context\n# defines the input of the Kform package as a configmap KRM resource\napiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example-app\nnamespace: example-system\nannotations:\nkform.dev/block-type: input\nkform.dev/resource-id: context kform.dev/default: \"true\"\ndata:\nimage: a.b\n---\n# blockType: input, resourceID: kubernetes\n# defines the kubernetes provider configuration\n# when nothing is specified the default kubeconfig is used\napiVersion: kubernetes.provider.kform.io/v1alpha1\nkind: ProviderConfig\nmetadata:\nname: kubernetes\nannotations:\nkform.dev/block-type: provider\nspec: ---\n# blockType: resource, resourceID: ns, resourceType: kubernetes_manifest\n# namespace KRM resource that will be applied to the system\n# metadata.name is transformed using an expression\napiVersion: v1\nkind: Namespace\nmetadata:\nname: input.context[0].metadata.namespace\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: ns ---\n# blockType: resource, resourceID: ns, resourceType: kubernetes_manifest\n# namespace KRM resource that will be applied to the system\n# expressions are used to transform the KRM manifest before applying to the system\nkind: ServiceAccount\napiVersion: v1\nmetadata:\nname: input.context[0].metadata.name\nnamespace: input.context[0].metadata.namespace\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: sa\n---\n# blockType: resource, resourceID: deployment, resourceType: kubernetes_manifest\n# deployment KRM resource that will be applied to the system\n# expressions are used to transform the KRM manifest before applying to the system\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: input.context[0].metadata.name\nnamespace: input.context[0].metadata.namespace\nlabels:\napp: \"input.context[0].metadata.name\"\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: deployment\nspec:\nreplicas: 1\nselector:\nmatchLabels:\napp: \"input.context[0].metadata.name\"\ntemplate:\nmetadata:\nlabels:\napp: \"input.context[0].metadata.name\"\nspec:\nserviceAccountName: \"input.context[0].metadata.name\"\ncontainers:\n- name: \"input.context[0].metadata.name\"\nimage: \"input.context[0].data.image\"\nimagePullPolicy: Always\n</code></pre>"},{"location":"02-language/02_files_dirs/","title":"Files and Directories","text":""},{"location":"02-language/02_files_dirs/#file-extension","title":"File extension","text":"<p>Code in the <code>Kform</code> language is stored in plain <code>yaml</code> files using <code>.yaml</code> or <code>.yml</code>.</p>"},{"location":"02-language/02_files_dirs/#directories-and-modulespackages","title":"Directories and modules/packages","text":"<p>A <code>KForm</code> module or package is a collection of <code>.yaml</code> or <code>.yml</code> files in a given directory. Nested directories are treated as independent <code>Kform modules/packages</code>.</p> <p><code>KForm</code> evaluates all of the configuration <code>yaml</code> files in a directory together, effectively treating the entire <code>KForm module/package</code> as a single document. Separating various blocks into different files is purely for the convenience of readers and maintainers, and has no effect on the <code>KForm module/package</code> behavior.</p> <p>A <code>KForm module/package</code> can use module/package blockTypes to explicitly include other <code>KForm modules/packages</code> into the configuration. These child <code>KForm modules/packages</code> can come from local directories (nested in the parent module's directory, or anywhere else on disk), or from external sources like a Registry.</p>"},{"location":"02-language/02_files_dirs/#root-kform-modulepackage","title":"Root KForm module/package","text":"<p><code>KForm</code> always runs in the context of a single root module/package. A complete <code>KForm</code> configuration consists of a root module/package and the tree of child modules/packages (which includes the modules/packages called by the root module/package, any modules/packages called by those modules/packages, etc.). Sometimes child modules/packages are also called <code>mixins</code>.</p> <p>In <code>Kform</code> CLI, the root module/package is the working directory where <code>Kform</code> is invoked/pointed at.</p>"},{"location":"02-language/03_syntax/","title":"Syntax","text":""},{"location":"02-language/attributes/about/","title":"KForm Attributes","text":"<p>Kform atrributes provide additional metadata on the KRM resources that are specific to KForm.</p>"},{"location":"02-language/attributes/count/","title":"Count attribute","text":"<p>A given resource cannot use both count and for_each.</p> <p>By default, a resource configures a single object. (Similarly, a module/package resource includes a child module's contents into the configuration one time.) However, sometimes you want to manage several similar resource (like a fixed pool of interfaces) without writing a separate resource for each one. Kform has two ways to do this: count and for_each.</p> <p>If a resource or module/package block includes a <code>count</code> argument whose value is a number, KForm will create that many instances.</p>"},{"location":"02-language/attributes/count/#usage","title":"Usage","text":"<p><code>count</code> is an attribute defined by the KForm language. You can use the <code>count</code> attribute in all block-types except the <code>input</code> block-type</p> <p>The count attribute accepts a whole number, and creates that many instances of the resource or module/package. Each instance has a distinct resource associated with it, and each is separately created, updated, or deleted when the configuration is applied.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: '[\"example\", count.index].concat(\"-\")'\nnamespace: example-system\nannotations:\nkform.dev/count: input.context[0].data.count\ndata:\nimage: count.index\n</code></pre>"},{"location":"02-language/attributes/count/#the-count-variable","title":"The count variable","text":"<p>In resources where the <code>count</code> attribute is specified, KForm automatically defines an additional <code>count</code> variable, enabling dynamic configuration adjustments for each instance. This <code>count</code> object facilitates modification of individual configurations within the resource. It comprises a single attribute:</p> <ul> <li>count.index: Represents the unique index number, starting from 0, associated with each instance, allowing precise identification and manipulation within the configuration.\"</li> </ul>"},{"location":"02-language/attributes/count/#using-expressions-in-count","title":"Using expressions in count","text":"<p>Numeric expressions can be used in the <code>count</code> attribute that are also used when Kform calculates the dependencies between resources.</p>"},{"location":"02-language/attributes/count/#referring-to-count-resources","title":"Referring to count resources.","text":"<p>A resource is always referred to as <code>&lt;RESOURCE-TYPE&gt;.&lt;RESOURCE-ID&gt;[INDEX]</code>. Normally Index is 0 but resources that use the <code>count</code> attribute could refer to an index different then 0.</p>"},{"location":"02-language/attributes/depends_on/","title":"Depends_on attribute","text":"<p>The <code>depends_on</code> attribute allows to handle hidden resource or module/package dependencies that <code>KFor</code>m cannot automatically infer. You only need to explicitly specify a dependency when a resource or module/package relies on another resource's behavior but does not access any of that resource's data in its arguments.</p>"},{"location":"02-language/attributes/depends_on/#processing-impact","title":"Processing impact","text":"<p>The <code>depends_on</code> attributes instructs Kform to complete all actions on the dependency resource  before performing any actions on the resource declaring the dependency. When the dependency resource is a module/package, <code>depends_on</code> affects the order in which Kform processes all of the resources associated with that module.</p> <p>Instead of <code>depends_on</code>, we recommend using expression references to imply dependencies when possible. Expression references let KForm understand which value the reference derives from and avoid planning changes if that particular value hasn\u2019t changed, even if other parts of the upstream object have planned changes.</p>"},{"location":"02-language/attributes/depends_on/#usage","title":"Usage","text":"<p>You can use the <code>depends_on</code> attribute in all block-types except the <code>input</code> block-type. It requires a list of references to other resources or child modules/packages in the same calling module/package expressed as a comma, seperated string. This list cannot include arbitrary expressions because the <code>depends_on</code> value must be known before Kform knows resource relationships and thus before it can safely evaluate expressions.</p> <p>It is good practice to document why a depend_on attribute is needed. The following example uses depends_on to handle a \"hidden\" dependency on the kubernetes_manifest.my-namespace.</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: my-namespace\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest ---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\nname: my-app\nnamespace: my-namespace\nlabels:\napp: my-app\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: deployment\n#depend_on hidden dependency to the kubernetes_manifest.my-namespace resource\nkform.dev/depends_on: kubernetes_manifest.my-namespace spec:\nreplicas: 1\nselector:\nmatchLabels:\napp: my-app\ntemplate:\nmetadata:\nlabels:\napp: my-app\nspec:\nserviceAccountName: my-app\ncontainers:\n- name: my-app\nimage: my-image\nimagePullPolicy: Always\n</code></pre>"},{"location":"02-language/attributes/description/","title":"Description attribute","text":"<p>A description attribute can be used to describe the purpose of the resource.</p>"},{"location":"02-language/attributes/description/#usage","title":"Usage","text":"<p>Below is an example usage of the description attribute.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example-app\nnamespace: example-system\nannotations:\nkform.dev/block-type: input\nkform.dev/resource-id: context kform.dev/default: \"true\"\nkform.dev/description: \"the context of the package, namespace, name, image\"\ndata:\nimage: a.b\n</code></pre>"},{"location":"02-language/attributes/for_each/","title":"For_each attribute","text":"<p>A given resource cannot use both count and for_each.</p> <p>By default, a resource configures a single object. (Similarly, a module/package resource includes a child module's contents into the configuration one time.) However, sometimes you want to manage several similar resource (like a fixed pool of interfaces) without writing a separate resource for each one. Kform has two ways to do this: count and for_each.</p> <p>If a resource or module/package block includes a <code>for_each</code> argument whose value is a map or a list, KForm will iterate over these elements in the map or list.</p>"},{"location":"02-language/attributes/for_each/#usage","title":"Usage","text":"<p><code>for_each</code> is an attribute defined by the KForm language. You can use the <code>for_each</code> attribute in all block-types except the <code>input</code> block-type</p> <p>The <code>for_each</code> attribute accepts a map or list, and creates that many instances of the resource or module/package. Each instance has a distinct resource associated with it, and each is separately created, updated, or deleted when the configuration is applied.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: '[\"example\", each.index].concat(\"-\")'\nnamespace: example-system\nannotations:\nkform.dev/for_each: input.context[0].data.entries\ndata:\nimage: each.key\n</code></pre>"},{"location":"02-language/attributes/for_each/#the-for_each-variable","title":"The for_each variable","text":"<p>In resources where the <code>for_each</code> attribute is specified, KForm automatically defines an additional <code>each</code> variable, enabling dynamic configuration adjustments for each instance. This <code>each</code> object facilitates modification of individual configurations within the resource. It comprises of two attribute:</p> <ul> <li>each.key: The map key (or list index) corresponding to this instance.</li> <li>each.value: The map or list value corresponding to this instance. </li> </ul>"},{"location":"02-language/attributes/for_each/#using-expressions-in-for_each","title":"Using expressions in for_each","text":"<p>Map or list expressions can be used in the <code>for_each</code> attribute. These expressions are included in the dependency calculation such that the data of the expression is available when rendering the resource using the <code>for_each</code> expression.</p>"},{"location":"02-language/attributes/for_each/#referring-to-for_each-resources","title":"Referring to for_each resources.","text":"<p>A resource is always referred to as <code>&lt;RESOURCE-TYPE&gt;.&lt;RESOURCE-ID&gt;[INDEX]</code>. Normally Index is 0 but resources that use <code>for_each</code> could refer to an index different then 0.</p>"},{"location":"02-language/attributes/lifecycle/","title":"Lifecycle attribute","text":""},{"location":"02-language/attributes/provider/","title":"Provider attribute","text":""},{"location":"02-language/attributes/sensitive/","title":"Sensitive attribute","text":"<p>TODO -&gt; inheritence of sensitive values</p>"},{"location":"02-language/attributes/sensitive/#usage","title":"Usage","text":""},{"location":"02-language/resources/about/","title":"Syntax","text":""},{"location":"02-language/resources/data_source/","title":"Data Source KForm Resource","text":"<p>The <code>KForm resource</code> block defines that you want a particular managed object to exist with a specific configuration. When applying the Kform configuration, kform manages the lifecycle of the given managed object, by either creating, updating or deleting the managed object through a provider.</p>"},{"location":"02-language/resources/data_sources/","title":"Data Sources KForm Resource","text":""},{"location":"02-language/resources/input/","title":"Input KForm Resource","text":"<p>Input <code>KForm</code> resources let you customize aspects of a Kform module/package without altering the KForm module/package source code/configuration. This functionality allows you to share <code>KForm modules/packages</code> across different Kform configurations, making your <code>KForm module/package</code> composable and reusable.</p> <p>When you declare an <code>input KRM resource</code> in the root module/package of your configuration, you can set their values using CLI options. When you declare <code>input KRM resource</code> in child modules/packages, the calling module/package should pass values in the module/package KRM resource.</p> <p>Kform's input resources can be compared to function arguments in traditional programming.</p>"},{"location":"02-language/resources/input/#input","title":"Input","text":"<p>A KRM resource is defined as an <code>input</code> blockType by setting the annotation <code>kform.dev/block-type = input</code>. An Input resource is uniquely identified by the combination of the blockType and its resourceID. The resourceID is defined by the <code>kform.dev/resource-id</code> annotation or the <code>metadata.name</code> if the <code>kform.dev/resource-id</code> annotation is not present. A resourceID is mandatory and must be unique accross input resources in the same module/package. </p> <p>An input resource example is shown below</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example-app\nnamespace: example-system\nannotations:\nkform.dev/block-type: input\nkform.dev/resource-id: context kform.dev/default: \"true\"\ndata:\nimage: a.b\n</code></pre>"},{"location":"02-language/resources/input/#attributes","title":"Attributes","text":"<p>The following optional attributes can be defined for input resources through annotations:</p> <ul> <li>default - A default value which then makes the input KRM resource optional.</li> <li>description - This specifies the input KRM resource documentation.</li> <li>sensitive - Limits UI output when the variable is used in configuration.</li> </ul>"},{"location":"02-language/resources/input/#default-attribute","title":"Default attribute","text":"<p>When an input resource is declared as default, the input KRM resource will be used if no input KRM resource with that resourceID is present when calling the module/package. A default input resource cannot have references/expressions with other resources.</p>"},{"location":"02-language/resources/input/#description-attribute","title":"Description attribute","text":"<p>description attribute</p>"},{"location":"02-language/resources/input/#sensitive-attribute","title":"Sensitive attribute","text":"<p>sensitive attribute</p>"},{"location":"02-language/resources/input/#using-input-resources","title":"Using Input Resources","text":"<p>Values from input resources can be accessed through expressions using the following syntax: - input., where  matches the resourceID that is either defined by the <code>kform.dev/resource-id</code> annotation or the <code>metadata.name</code> if the <code>kform.dev/resource-id</code> annotation is not present. <p>In the example below, the input resource e.g. <code>input.context</code> can only be accessed in expressions within the module/package where it was declared. Also note that <code>KForm</code> stores the resources as a list, which means expressions must use <code>input.context[0]</code> to access the values of the first entry in the list.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example-app\nnamespace: example-system\nannotations:\nkform.dev/block-type: input\nkform.dev/resource-id: context kform.dev/default: \"true\"\ndata:\nimage: a.b\n</code></pre> <p>When using input resources, they must be defined within the module/package, if not the <code>Kform</code> parser will throw an error</p>"},{"location":"02-language/resources/input/#customizing-input-resources-within-a-modulepackage","title":"Customizing input resources within a module/package","text":"<p>Input Resources that are declared in the root module/package of your configuration, can be customized through:</p> <ul> <li>cli options: -i (input file or input dir), which can source from a file or directory</li> <li>kform library using the inputData variable</li> </ul> <p>The input resources, specified as dynamic input can omit the block-type annotation since kform knows these that dynamic input data are to be used as input block-types.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: my-app\nnamespace: my-system\nannotations:\nkform.dev/resource-id: context data:\nimage: my-image\n</code></pre>"},{"location":"02-language/resources/input/#command-line","title":"command line","text":"<p>To customize the input resources used in a module/package, an input file or directory can be specified in the command line. </p> <pre><code>kform apply -i &lt;input file or input dir&gt;\n</code></pre>"},{"location":"02-language/resources/input/#kform-library","title":"kform library","text":"<p>When using Kform as a library, you can specify the input resources in the input data.</p> <pre><code>kfrunner := runner.NewKformRunner(&amp;runner.Config{\nPackageName:  cr.Spec.PackageID.Package,\nInputData:    inputData,\nResourceData: resourceData,\nOutputData:   outputData,\n})\n</code></pre>"},{"location":"02-language/resources/input/#declaring-input-resources","title":"Declaring input resources","text":"<p>When using dynamic input resource, <code>KForm</code> will validate if the corresponding input is defined within the package, if not a WARNING message will be shown since this data will not be used.</p> <p>e.g. if you define within your module/package the following input resource</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: example-app\nnamespace: example-system\nannotations:\nkform.dev/block-type: input\nkform.dev/resource-id: context kform.dev/default: \"true\"\ndata:\nimage: a.b\n</code></pre> <p>The following dynamic input resource is specified with a resourceID that is unknown (e.g. ctx in this case), <code>KForm</code> will throw a warning to indicate the potential misconfiguration.</p> <pre><code>apiVersion: v1\nkind: ConfigMap\nmetadata:\nname: my-app\nnamespace: my-system\nannotations:\nkform.dev/resource-id: ctx\ndata:\nimage: my-image\n</code></pre>"},{"location":"02-language/resources/input/#input-resource-preference","title":"Input Resource Preference","text":"<p>Kform will prioritize dynamic input resources over the once specified in the module/package itself.</p>"},{"location":"02-language/resources/module/","title":"Module KForm Resource","text":""},{"location":"02-language/resources/output/","title":"Output KForm Resource","text":"<p>Output Resources serve as a means to share resource data beyond the confines of your module or package, enabling other components to utilize this information for subsequent operations.</p> <p>Similar to return values in programming languages, Output Resources provide several benefits:</p> <ul> <li>Child modules or packages can utilize outputs to expose specific resource attributes to a parent module, facilitating modular design and encapsulation.</li> <li>Consumers of the root module or package can employ output resources to display selected values in the CLI output post-execution of <code>kform apply</code>.</li> <li>Output resources from the root module or package can be leveraged for various post-processing tasks, such as utilizing GitOps tools to apply the resources to the cluster, among other operations.\"</li> </ul>"},{"location":"02-language/resources/output/#output-resource","title":"Output Resource","text":"<p>A KRM resource is defined as an <code>output</code> blockType if no <code>kform.dev/block-type</code> annotation is present or when you explicitly set the annotation <code>kform.dev/block-type = output</code>. The flexibility of omitting the <code>kform.dev/block-type</code> annotation ensures that any KRM module/package can be consumed as a <code>KForm module.package</code>.</p> <p>An output resource is uniquely identified by the combination of the blockType and its resourceID. The resourceID is defined by the <code>kform.dev/resource-id</code> annotation or the <code>metadata.name</code> if the <code>kform.dev/resource-id</code> annotation is not present. A resourceID is mandatory and must be unique accross ouput resources in the same module/package. </p> <p>The following examples show how to define output resources, the first omits the blockType and resourceID, while the second one explicitly sets the block-type and resource-id.</p> <p>Example where the output block-type is implied</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: my-system\n</code></pre> <p>Example where the output block-type is explicitly defined</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: my-system\nannotations:\nkform.dev/block-type: output\nkform.dev/resource-id: ns </code></pre>"},{"location":"02-language/resources/output/#attributes","title":"Attributes","text":"<p>The following optional attributes can be defined for input resources through annotations:</p> <ul> <li>description - specifies the resource documentation.</li> <li>sensitive - limits the output in the configuration.</li> <li>depends_on -  defines hidden resource dependencies</li> <li>count - allows to multiply a resource or can be used as a conditional expression</li> <li>for_each -  allows to multiply a resource</li> </ul>"},{"location":"02-language/resources/output/#description-attribute","title":"Description attribute","text":"<p>description attribute</p>"},{"location":"02-language/resources/output/#sensitive-attribute","title":"Sensitive attribute","text":"<p>sensitive attribute</p>"},{"location":"02-language/resources/output/#depends_on-attribute","title":"Depends_on attribute","text":"<p>depends_on attribute</p>"},{"location":"02-language/resources/output/#count-attribute","title":"Count attribute","text":"<p>count attribute</p>"},{"location":"02-language/resources/output/#for_each-attribute","title":"For_each attribute","text":"<p>for_each attribute</p>"},{"location":"02-language/resources/provider/","title":"Provider KForm Resource","text":""},{"location":"02-language/resources/resource/","title":"Resource KForm Resource","text":"<p>The <code>KForm resource</code> block defines that you want a particular managed object to exist with a specific configuration. When applying the Kform configuration, kform manages the lifecycle of the given managed object, by either creating, updating or deleting the managed object through a provider.</p>"},{"location":"02-language/resources/resource/#resource","title":"Resource","text":"<p>A KRM resource is defined as a <code>resource</code> blockType by setting the annotation <code>kform.dev/block-type = resource</code>. While the blockType is defined as resource, a specific <code>kform.dev/resource-type</code> has to be defined for a blockType = resource. On top to uniqly identify a resource a resourceID is defined through the <code>kform.dev/resource-id</code> annotation or the <code>metadata.name</code> if the <code>kform.dev/resource-id</code> annotation is not present. A resourceID is mandatory and must be unique accross input resources in the same module/package. </p> <p>A resource example is shown below, where the resource-type = kubernetes_manifest and resource-id = ns</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: my-namespace\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: ns </code></pre>"},{"location":"02-language/resources/resource/#provider","title":"Provider","text":"<p>Resource are managed though a provider, which offers a collection of resource types. Providers are distributed independently from Kform, but Kform can install the providers when initializing a working module/package.</p> <p>To manage resources, a Kform module/package must specify the required providers. Refer to Provider Requirements for additional information.</p> <p>Most providers need some configuration to access their remote API, which is provided by the root module. Refer to Provider Configuration for additional information.</p> <p>Based on a resource type's name, Kform can usually determine which provider to use. By convention, resource type names start with their provider's preferred local name. When using multiple configurations of a provider or non-preferred local provider names, you must use the provider attribute to manually choose a provider configuration.</p>"},{"location":"02-language/resources/resource/#attributes","title":"Attributes","text":"<p>The following optional attributes can be defined for resources through annotations:</p> <ul> <li>description - for specifying the resource documentation.</li> <li>sensitive - for limiting the output of the configuration.</li> <li>depends_on - for specifying hidden dependencies.</li> <li>count -  to create multiple resource instances according to a number or can serve as a conditional expression</li> <li>for_each - to create multiple resource instances according to a map, or set of strings</li> <li>provider - for selecting a specific provider configuration</li> <li>lifecycle - for determining if Kform should delete or orphan the managed resource</li> <li>precondition - todo</li> <li>postcondition - todo</li> <li>provisioner - todo</li> </ul>"},{"location":"02-language/resources/resource/#description-attribute","title":"Description attribute","text":"<p>description attribute</p>"},{"location":"02-language/resources/resource/#sensitive-attribute","title":"Sensitive attribute","text":"<p>sensitive attribute</p>"},{"location":"02-language/resources/resource/#depends_on-attribute","title":"Depends_on attribute","text":"<p>depends_on attribute</p>"},{"location":"02-language/resources/resource/#count-attribute","title":"Count attribute","text":"<p>count attribute</p>"},{"location":"02-language/resources/resource/#for_each-attribute","title":"For_each attribute","text":"<p>for_each attribute</p>"},{"location":"02-language/resources/resource/#provider-attribute","title":"Provider attribute","text":"<p>provider attribute</p>"},{"location":"02-language/resources/resource/#lifecycle-attribute","title":"Lifecycle attribute","text":"<p>lifecycle attribute</p>"},{"location":"02-language/resources/resource/#deleting-a-resource","title":"Deleting a resource","text":"<p>To remove a resource from Kform, simply delete the resource block from your Kform configuration.</p> <p>By default, after you remove the resource block, Kform will plan to destroy any real object managed by that resource.</p> <p>Sometimes you may wish to remove a resource from your Kform configuration without destroying the real object it manages. In this case, the resource will be removed from the Kform state, but the real object will not be destroyed. In order to do so add the lifecycle annotation = orphan as per example below</p> <pre><code>apiVersion: v1\nkind: Namespace\nmetadata:\nname: my-namespace\nannotations:\nkform.dev/block-type: resource\nkform.dev/resource-type: kubernetes_manifest kform.dev/resource-id: ns kform.dev/lifecycle: orphan </code></pre>"},{"location":"02-language/resources/resource/#custom-condition-checks","title":"Custom condition checks","text":"<p>precondition ??? postcondition ???</p>"},{"location":"02-language/resources/resource/#operation-timout","title":"Operation Timout","text":"<p>to be specified in the provider config</p>"},{"location":"06-rn/rn/","title":"Kform release notes","text":"<p>We are stil in the early phases of our development, therefore we do not publish aggregated release notes for each of our releases. </p> <p>Release summaries are available on GitHub:</p> <ul> <li>Kform</li> </ul>"},{"location":"07-community/01_about/","title":"Community","text":"<p>Join us in this jurney to build the power of 'KRM as code or data' to Kubernetes. We are happy to help and would like to learn your user stories in the Kubenet discord server.</p> <p>Kform was started and currently maintained by Nokia with the clear target to make the project community driven.</p>"},{"location":"07-community/01_about/#kubenet","title":"Kubenet","text":"<p>If you are intrested in a biger picture about how do we imagine network manegement in a Kubernetes native way check out Kubenet. </p>"},{"location":"07-community/01_about/#logos","title":"Logos","text":"<p>Logos of Kform in different formats:</p> <ul> <li>With name 100x123 png</li> <li>With name 503x690 png</li> <li>Without name 100x100 png</li> <li>With name svg</li> <li>Without name svg</li> </ul> <p></p>"}]}